{"meta":{"title":"koala's blog","subtitle":"慢慢来，请相信自己 。","description":null,"author":"XHY","url":"https://koala949.github.io","root":"/"},"pages":[],"posts":[{"title":"react学习笔记(二)","slug":"0723","date":"2019-08-26T10:19:25.186Z","updated":"2019-08-26T10:20:09.921Z","comments":true,"path":"2019/08/26/0723/","link":"","permalink":"https://koala949.github.io/2019/08/26/0723/","excerpt":"","text":"react学习(二) 组件复用单项数据流，数据只能从父级组件传给子级。 ref一般的react数据流中，父级与子级是通过props进行沟通，如果要子级发生改变，父级可以改变传入的props.但是有时需要强制修改子级,则要用到ref.适用场景：(1)处理焦点，文本选择，媒体控制(2)触发强制动画(3)集成第三方dom库。 状态提升当多个组件依赖某个状态或者多个组件会影响到某个状态，此时将该状态提升至这多个组件的父组件。然后以 props 传递，而对该状态的改变也由父级来控制，子级只是调用父级改变状态的那个方法。 context在 react 中，数据以自上到下的方向传递，如果一个数据在最顶层，而最底层的组件需要用到这个数据，那么数据需要传递很多层才能到达最底层。这种操作会异常麻烦。顶层父组件中添加 childContextTypes 和 getChildContext, context 就会向下传递。在需要引入的子组件中添加 contextTypes, 即可以 this.context 获取。 Redux学习npm install redux –save 1.基础了解 redux 专注于管理状态，和react解耦 单一状态，单一数据流 核心概念：store，state，action，reducer store包含所有属性的状态state，当要发生改变时，dispatch方法获取到action，reducer拿到state和action处理变化，生成新的state。===&gt; 首先通过reducer新建store，随时通过store.getState获取状态===&gt;需要状态变更，store.dispatch(action)来修改状态===&gt;reducer 函数接受state和action，返回心得state，可以用store.subscribe监听每次修改。 与react使用===&gt;把store.dispatch方法传递给组件，内部可以调用修改状态。===&gt;Subscribe订阅render函数，每次修改都重新渲染===&gt;redux相关内容，移交单独的文件index.redux.js单独管理。 redux 处理异步需要redux-thunk 插件，npm install redux-devtools-extension 开启该调试工具。ant design","categories":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/tags/react/"}]},{"title":"react学习笔记(一)","slug":"0722","date":"2019-08-26T10:10:31.204Z","updated":"2019-08-26T10:20:06.362Z","comments":true,"path":"2019/08/26/0722/","link":"","permalink":"https://koala949.github.io/2019/08/26/0722/","excerpt":"","text":"react学习笔记(一) 使用脚手架create-react-app,安装好之后了解结构。yarn.lock 定义了当前使用的确切版本。 还需要用到webpack JSX语法 (1)class写成className，某写属性比如for 要写成 htmlFor. (2)属性值使用表达式，只要用 {} 替换 “”: (3)属性扩散 var props={}; props.foo =x; props.bar =y; var component = &lt;Component {...props}/&gt; props对象的属性会被设置成Component的属性。 render渲染 react 构建用户界面的库，其元素是JSX元素，其实使用JS来描 述页面对象。render的含义就是把一个react元素渲染到dom 容器内部。 reactDoM.render( React.createElement(&apos;div&apos;,null,[React.createElement(&apos;span&apos;,null,[&apos;hello&apos;])]), document.querySelector(&apos;#root&apos;));标签类型，属性对象，子元素。属性名都要写成驼峰写法。//经过webpack转译后会变成以下形式。 ReactDOM.render(&lt;div&gt; &lt;span&gt;hello&lt; /sapn&gt; &lt;/div&gt;,docoment.querySelector(&apos;#root&apos;)); 小示例：map使用，加key，设置样式和类名 let names = [&apos;一&apos;，&apos;二&apos; ,&apos;三&apos;] ReactDom.render(&lt;div&gt;{ names.map(function (item,index){ return item.length&gt;0?&lt;span style={{backgroundColor:'pink'}} className = &quot;red&quot; key={index}&gt;{item}&lt;/span&gt;:null }) }&lt;/div&gt;,document.querySelector(&apos;#root&apos;)); //有条件的渲染： return item.length&gt;0? tips: 设置数据一定要用setState,如果没用箭头函数则要进行绑定。 123456this.handle =thid.handle.bind(this)handle = ()=&gt;&#123; this.setState&#123; reflash=1, &#125;&#125; 没有default时，引用要有{} 组件 直观的将一个复杂的页面分割成若干个独立组件，每个组件包含自己的逻辑和样式，既减少逻辑复杂度，又实现代码重用。两种组件定义方式：(1)函数声明函数参数是属性对象,首字母一定是大写，定义完之后可以像react元素一样使用。组件的渲染过程：封装props对象，调用组件函数得到返回的React元素，ReactDOM把元素转成真实的DOM元素并插入到目标容器。 let Message = (props)=&gt;{ return &lt;h1&gt;{props.msg}&lt;/h1&gt; }或 let Message = ({msg，id}) =&gt;{ return &lt;h1&gt;{msg}&lt;/h1&gt; } render(&lt;Message msg=&apos;hello&apos; id=&quot;5&quot;/&gt;,...) // 解构： import ReactDom,{render} from &apos;react-dom&apos;;函数声明的组件是静态的，否则要手动添加。 setInterval(function(){ render(&lt;Clock/&gt;,...) },1000) (2)类声明通过类声明组件，类需要继承自Component class Clock extends Component{ constructor(){ super();//自定义组件状态对象 //状态可以用来存放组件内部一些变化的值， this.state = {time:new Date().toLocalString()} } //生命周期函数 componentDidMount(){ window.setInterval(()=&gt;{ this.setState({ time:new Date().toLocalString()}) },1000); } } 组件属性(1) 默认属性static defaultProps ={ name:’aaa’}(2) 如果定义组件时希望传入组件的属性有类型和是否必填的限制，则使用ProTypes。组件的属性可以接受任意值，字符串、对象、函数。使用组件的proType属性，验证组件的实例属性是否符合要求。 var MyTitle = React.creatClass({ proTypes:{ title : React.ProTypes.string.isRequired, }, render: function(){ return &lt;h1&gt;{this.props.title}&lt;/h1&gt; } } var data = 123; ReactDom.render(&lt;MyTile title={data}/&gt;,document.body); 验证不通过。(3) React 提供React.Children 来处理this.props.children,可以用React.Children.map来遍历子节点。 (4) Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。 虚拟DOM对DOM进行模拟，比较操作前后的数据差异，如果有数据差异，同意操作DOM.(1)受控组件(2)非受控组件","categories":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/tags/react/"}]}]}