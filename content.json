{"meta":{"title":"koala's blog","subtitle":"慢慢来，请相信自己 。","description":null,"author":"XHY","url":"https://koala949.github.io","root":"/"},"pages":[],"posts":[{"title":"react学习笔记(四)","slug":"react-router","date":"2019-09-10T02:44:56.509Z","updated":"2019-09-10T05:13:39.850Z","comments":true,"path":"2019/09/10/react-router/","link":"","permalink":"https://koala949.github.io/2019/09/10/react-router/","excerpt":"","text":"redux-router学习安装 react-router-dom import { BrowserRouter as Router, Route, Link } from &quot;react-router-dom&quot;; 内容：Router包裹在外层 123456789&lt;Router&gt; &lt;div&gt; &lt;Header /&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;/topics&quot; component=&#123;Topics&#125; /&gt; &lt;Route component=&#123;Always&#125;/&gt; // renders &lt;Always/&gt; &lt;/div&gt; &lt;/Router&gt; 注意点： exact是Route的一个属性，认为其是一个严格匹配模式。当exact为false，根据路由匹配所有组件；当exact为true，则’/‘仅匹配’/‘.实际中设置该属性，取决于页面的构造.若一个路由对应一个独立的页面(非嵌套)。则可使用exact：true ，这样能够保证在路由为“/home”时不会匹配到’/‘对应组件。若一个路由对应是页面中局部view时，则exact设为false，否则因“/home/menu” 无法匹配“/home”，导致父组件无法渲染更别提嵌套的局部view。 this.props.history.push(&#39;/path&#39;)可以直接进行页面跳转； Link的使用 参数的获取：使用this.props.match.params.xxx可以获取到当前路由的参数 Redirect 应用例子：&lt;Route path=&#39;/&#39; render={()=&gt;(&lt;Redirect to=&#39;/views&#39; /&gt;)}&gt;&lt;/Route&gt;&lt;Redirect from=&quot;/&quot; to=&quot;/home&quot; /&gt; 函数组件的context Context设计的目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题，提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。","categories":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/tags/react/"},{"name":"react-router","slug":"react-router","permalink":"https://koala949.github.io/tags/react-router/"}]},{"title":"react学习笔记(三)","slug":"react-saga","date":"2019-08-29T11:09:05.841Z","updated":"2019-08-30T02:29:46.650Z","comments":true,"path":"2019/08/29/react-saga/","link":"","permalink":"https://koala949.github.io/2019/08/29/react-saga/","excerpt":"","text":"redux-saga学习直接模拟示例：在我们开始前，clone 这个教程仓库从最简单的用例开始：2个按钮增加(increment)和减少(decrement)计数，之后再添加异步。 (1)创建sagas.js文件，添加以下代码： 123export function *helloSaga()&#123; console.log(&apos;Hello Sagas!&apos;)&#125; 为了运行saga,需要：创建一个Saga middleware 和要运行的 Sagas(目前只有helloSaga)将这个 Saga middleware 连接至 Redux store (2)修改 main.js 12345678910import &#123; createStore , applyMiddleware &#125; from &apos;redux&apos;import createSagaMiddleware from &apos;redux-saga&apos;//...import &#123; helloSaga &#125; from &apos;./sagas&apos;const store = createStore( reducer, applyMiddleware( createSagaMiddleware(helloSaga))) 引入./sagas模块中的Saga，使用redux-saga 模块中的createSagaMiddleware工厂函数来创建一个Saga middleware。 在运行helloSaga之前，必须使用applyMiddleware将middleware连接至Store，然后使用SagaMiddleware.run(helloSaga)运行Saga。打印一条消息。 (3)发起异步调用来添加一些更接近原始计数器例子的东西。为了演示异步调用，添加另一个按钮用于在点击一秒后增加技术。在UI组件上添加一个额外的按钮和一个回调onIncrementAsync。 123456789101112131415const Counter = (&#123; value, onIncrement, onDecrement, onIncrementAsync&#125;) =&gt;&lt;div&gt; &lt;button onClick=&#123; onIncrementAsync&#125;&gt; increment after 1 second &lt;/button&gt; &#123; &apos; &apos;&#125; &lt;button onClick=&#123; onIncrement&#125;&gt;Increment&lt;/button&gt; &#123;&apos; &apos;&#125; &lt;button onClick=&#123;onDecrement&#125;&gt; Decrement &lt;/button&gt; &lt;hr /&gt; &lt;div&gt; Clicked: &#123;value&#125; times &lt;/div&gt; &lt;&gt;&lt;/div&gt; (4)将组件的onIncrementAsync 与 Store action 连接起来。 修改main.js 1234567891011function render()&#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement = &#123;()=&gt;action(&apos;INCREMENT&apos;)&#125; onIncrement = &#123;()=&gt;action(&apos;DECREMENT&apos;)&#125; onIncrementAsync = &#123;()=&gt; action(&apos;INCREMENT_ASYNC&apos;)&#125; /&gt;, document.getElementById(&apos;root&apos;) )&#125; 该组件dispatch的是一个 plain Object 的action。 (5)现添加另一种执行异步调用的Saga，用例如下：在每个 INCREMENT_ASYNC action 启动一个做以下事情的任务：等待1秒，然后增加计数。sagas.js 123456789101112import &#123; delay &#125; from &apos;redux-saga&apos;import &#123; put, takeEvery &#125; from &apos;redux-saga/effects&apos;// Our worker Saga: 将执行异步的 increment 任务export function* incrementAsync() &#123; yield delay(1000) yield put(&#123; type: &apos;INCREMENT&apos; &#125;)&#125;// Our watcher Saga: 在每个 INCREMENT_ASYNC action spawn 一个新的 incrementAsync 任务export function* watchIncrementAsync() &#123; yield takeEvery(&apos;INCREMENT_ASYNC&apos;, incrementAsync)&#125; (6)现在我们有了 2 个 Sagas，我们需要同时启动它们。为了做到这一点，我们将添加一个 rootSaga，负责启动其他的 Sagas。在同样的 sagas.js 文件中，添加内容： 123456export default function* rootSaga() &#123; yield all([ helloSaga(), watchIncrementAsync() ])&#125; (7)在 main.js 的 root Saga 中调用 sagaMiddleware.run。 12345678// ...import rootSaga from &apos;./sagas&apos;const sagaMiddleware = createSagaMiddleware()const store = ...sagaMiddleware.run(rootSaga)// ...","categories":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/tags/react/"},{"name":"saga","slug":"saga","permalink":"https://koala949.github.io/tags/saga/"}]},{"title":"react学习笔记(二)","slug":"react-redux","date":"2019-08-29T02:36:31.897Z","updated":"2019-09-10T08:47:02.632Z","comments":true,"path":"2019/08/29/react-redux/","link":"","permalink":"https://koala949.github.io/2019/08/29/react-redux/","excerpt":"","text":"redux学习1.安装npm install --save reduxnpm install --save react-redux react 绑定库 2.三大原则(1)单一数据源整个应用的state被存储在一棵对象树中，并且这个对象树只存在于唯一一个store中。 { visibilityFilter: &apos;SHOW_ALL&apos;, todos: [ { text: &apos;Consider using Redux&apos;, completed: true, }, { text: &apos;Keep all state in a single tree&apos;, completed: false } ] }(2)state是只读的唯一改变state的方法是触发action，action是一个用于描述已发生事件的普通对象。(可以被日志打印、序列化、储存、后期调试或测试时回放出来。) store.dispatch({ type: &apos;COMPLETE_TODO&apos;, index: 1 }) store.dispatch({ type:&apos;SET_VISIBILITY_FILTER&apos;, filter:&apos;SHOW_COMPLETED&apos; })(3)使用纯函数来执行修改为了描述action如何改变state tree，还需要编写reducersreducer 先接收先前的state和action，并返回新的state。因为reducer只是函数，因此可以控制被调用的顺序，传入附加数据. 1234567891011121314151617181920212223242526272829303132function visibilityFilter( state = &apos;SHOW_ALL&apos;, action)&#123; switch(action.type)&#123; case &apos;SET_VISIBILITY_FILTER&apos;: return action.filter default: return state &#125; &#125;function todos(state = [],action)&#123; switch(action.type)&#123; case &apos;ADD_TODO&apos;: return [ ...state,&#123; text: action.text, completed : false &#125;] case &apos;COMPLETE_TODO&apos;: return state.map((todo,index)=&gt;&#123; if(index === action.index)&#123; return Object.assign(&#123;&#125;, todo, &#123; completed: true &#125;) &#125; return todo &#125;) default: return state &#125; &#125;import &#123; combineReducers, createStore &#125; from &apos;redux&apos;let reducer = combineReducers(&#123; visibilityFilter ,todos&#125;)let store = createStore(reducer) 3.Actionaction一般来说通过 store.dispatch() 将 action 传到 store。 我们约定，action内必须使用一个字符串类型的type 字段来表示将要执行的动作，多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放action。import { ADD_TODO, REMOVE_TODO } from &#39;../actionTypes&#39; 我们还需要再添加一个action index来表示用户完成任务的动作序列号，因为数据时存放在数组中，通过下标index来引用特定的任务，而实际项目中一般会在新建数据的时候生成唯一的ID作为数据的引用标识。我们应该减少在action 中传递的数据。 action创建函数Action 创建函数 就是生成 action 的方法。在 Redux 中的 action 创建函数只是简单的返回一个 action: function addTodo(text) { return { type: ADD_TODO, text } }Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。dispatch(addTodo(text))或者创建一个 被绑定的 action 创建函数来自动 dispatch,然后直接调用：const boundAddTodo = text =&gt;dispatch(addTodo(text))boundAddTodo(text); 4.reducerreducers 指定了应用状态的变化如何响应 actions 并发送到 store。 设计State结构以todo为例，需要保存两种不同的数据：当前选中的任务过滤条件；完整的任务列表。 Action处理需要谨记reducer一定要保持纯净，只要传入的参数相同，返回计算得到的下一个state就一定相同，没有特殊情况，没有副作用，没有API请求，没有变量修改，单纯执行计算。 开始编写 reducer，并让它来处理之前定义过的 action。以指定的state的初始状态作为开始，redux首次执行时，state为undefined，使用es6参数默认值语法精简代码。 function todoApp(state = initialState, action) { // 这里暂不处理任何 action， // 仅返回传入的 state。 return state }5.StoreStore 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener)注册监听器; 通过 subscribe(listener)返回的函数注销监听器。 6.数据流redux应用中数据的生命周期遵循下面4个步骤：(1)调用store.dispatch(action)(2)redux store 调用传入的reducer函数。(3)根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。(4)Redux store 保存了根 reducer 返回的完整 state 树。 整体步骤：===&gt; 定义规则===&gt; 计算规则生成store===&gt; 定义数据(即state)变化之后的派发规则===&gt; 触发数据变化。 8.工具安装：redux-devtools： 123const store = createStore(rootReducer,initialState, window.devToolsExtension ? window.devToolsExtension(): undefined ) 源码actions.js123456789101112131415161718192021222324252627282930313233/** action 类型*/export const ADD_TODO = &apos;ADD_TODO&apos;;export const TOGGLE_TODO = &apos;TOGGLE_TODO&apos;export const SET_VISIBILITY_FILTER = &apos;SET_VISIBILITY_FILTER&apos;/** 其它的常量*/export const VisibilityFilters = &#123;SHOW_ALL: &apos;SHOW_ALL&apos;,SHOW_COMPLETED: &apos;SHOW_COMPLETED&apos;,SHOW_ACTIVE: &apos;SHOW_ACTIVE&apos;&#125;/** action 创建函数*/export function addTodo(text) &#123;return &#123; type: ADD_TODO, text &#125;&#125;export function toggleTodo(index) &#123;return &#123; type: TOGGLE_TODO, index &#125;&#125;export function setVisibilityFilter(filter) &#123;return &#123; type: SET_VISIBILITY_FILTER, filter &#125;&#125; reducers.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123; combineReducers &#125; from &apos;redux&apos;import &#123; ADD_TODO, TOGGLE_TODO, SET_VISIBILITY_FILTER, VisibilityFilters&#125; from &apos;./actions&apos;const &#123; SHOW_ALL &#125; = VisibilityFiltersfunction visibilityFilter(state = SHOW_ALL, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return action.filter default: return state &#125;&#125;function todos(state = [], action) &#123; switch (action.type) &#123; case ADD_TODO: return [ ...state, &#123; text: action.text, completed: false &#125; ] case TOGGLE_TODO: return state.map((todo, index) =&gt; &#123; if (index === action.index) &#123; return Object.assign(&#123;&#125;, todo, &#123; completed: !todo.completed &#125;) &#125; return todo &#125;) default: return state &#125;&#125;const todoApp = combineReducers(&#123; visibilityFilter, todos&#125;)export default todoApp store.js1234import &#123; createStore &#125; from &apos;redux&apos;import todoApp from &apos;./reducers&apos;let store = createStore(todoApp)","categories":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://koala949.github.io/tags/redux/"}]},{"title":"git命令","slug":"git-操作","date":"2019-08-28T12:32:56.283Z","updated":"2019-09-10T08:57:54.546Z","comments":true,"path":"2019/08/28/git-操作/","link":"","permalink":"https://koala949.github.io/2019/08/28/git-操作/","excerpt":"","text":"从远程拉取代码及相关操作git clone &lt;remote_url&gt; git checkout –b &lt;newBranch&gt; git add &lt;file&gt; git commit –m “commit information” git pull origin &lt;remote_branch&gt; git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; 撤销操作分三种情况：第一种：没有执行add指令 git checkout -- &lt;file&gt;第二种：执行了add指令，未执行commit指令 git reset HEAD &lt;file&gt; 暂存区内容回退 git checkout -- &lt;file&gt; 丢弃工作区修改第三种：执行了commit指令，未提交到远程 git reset --hard &lt;commit_id&gt;版本回退 查看提交历史 git log git log --pretty=oneline 一行显示 版本回退 git reset --hard &lt;commit_id&gt; (HEAD指向当前版本，HEAD^上个版本，HEAD^^上上个版本……) git reset --soft e79fcfb: 回退到某次提交，并且把commit的内容撤回到暂存区 重返未来 git reflog查看命令历史 对比差异 git diff 查看工作区与版本库中的不同 git diff HEAD -- &lt;file&gt;查看某个文件的不同 文件被提交到版本库，想删除.第一步：删除工作区文件 rm &lt;file&gt;第二步：删除版本库中的文件 git rm &lt;file&gt; git commit --m “remove file” 解决冲突 执行 git merge &lt;branch name&gt; ，如果发生冲突，先解决冲突，再提交 查看分支合并图： git log --graph --pretty=oneline --abbrev-commit 分支管理创建分支 git checkout -b &lt;branch&gt; 查看分支 git branch 查看本地分支 git branch -r 查看远程分支 git branch -a 查看所有分支 切换分支 git checkout &lt;branch&gt; 删除分支 git branch -d &lt;branch&gt; 合并分支 git merge &lt;branch&gt; 暂存当前分支 git stash git stash [save &quot;msg&quot;]：储藏当前暂存的文件，[并提交储藏信息] 查看stash内容 git stash list 存储列表 恢复工作现场方式一： git stash apply 仅恢复 git stash apply stash@{0}: 应用某次储藏(不会删除那一次) git stash drop 删除方式二： git stash pop 恢复且删除，（应用并弹出栈顶的储藏） 练习==&gt; git branch xhy 创建分支 (相当于复制一份)==&gt; git branch 查看本地分支==&gt; git branch -a 查看所有分支==&gt; git checkout xhy 切换分支==&gt; 修改文件后==&gt; git add .==&gt; git commit -m “add”==&gt; git checkout master==&gt; git merge xhy==&gt; git pull==&gt; git push==&gt; git checkout xhy==&gt; git pull origin master ：推送到远程分支之后，就要回到你自己的分支继续开发，为了获取到远程分支的最新更改，所以要重新pull一下 写在后面：hexo博客命令hexo init [folder] 新建一个网站hexo new [layout] &lt;title&gt;创建一篇新文章hexo sever或hexo s 启动服务器hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo generate或hexo g 生成静态文件hexo deploy或hexo d部署网站hexo migrate &lt;type&gt;从其他博客系统迁移内容","categories":[{"name":"常用","slug":"常用","permalink":"https://koala949.github.io/categories/常用/"}],"tags":[{"name":"git","slug":"git","permalink":"https://koala949.github.io/tags/git/"}]},{"title":"markdown写作规范","slug":"md规范","date":"2019-08-27T09:24:19.342Z","updated":"2019-09-10T08:58:14.338Z","comments":true,"path":"2019/08/27/md规范/","link":"","permalink":"https://koala949.github.io/2019/08/27/md规范/","excerpt":"","text":"写作规范Markdown 教程(click)前言中文技术文档的写作规范。由于参与我们手册编著的同学写作习惯各不相同，为了统一我们的文章写作风格，尽量减少低级错误提高文章质量，我们需要规定一下我们的写作规范，以及推荐一下常用的文章结构。 标题小章节的一级标题统一使用 H3（标题 3） 层级标题分为四级。 一级标题：文章的标题 二级标题：文章主要部分的大标题 三级标题：二级标题下面一级的小标题 四级标题：三级标题下面某一方面的小标题 下面是示例。 1234567# 一级标题## 二级标题### 三级标题#### 四级标题 原则（1）一级标题下，不能直接出现三级标题。 示例：下面的文章结构，缺少二级标题。 123# 一级标题### 三级标题 （2）标题要避免孤立编号（即同级标题只有一个）。 示例：下面的文章结构，二级标题 A只包含一个三级标题，完全可以省略三级标题 A。 12345## 二级标题 A### 三级标题 A## 二级标题 B （3）下级标题不重复上一级标题的名字。 示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。 123## 概述### 概述 （4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。 如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。 示例：下面的结构二要好于结构一。后者适用的场景，主要是较长篇幅的内容。 12345678910111213141516171819结构一### 三级标题#### 四级标题 A#### 四级标题 B#### 四级标题 C结构二### 三级标题**（1）A****（2）B****（3）C** 文本字间距（1）全角中文字符与半角英文字符之间，应有一个半角空格。 123错误：本文介绍如何快速启动Windows系统。正确：本文介绍如何快速启动 Windows 系统。 （2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。 123正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。 半角的百分号，视同阿拉伯数字。 123正确：今年我国经济增长率是6.5%。正确：今年我国经济增长率是 6.5%。 （3）英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。 123错误：一部容量为 16 GB 的智能手机正确：一部容量为 16GB 的智能手机 （4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。 123错误：他的电脑是 MacBook Air 。正确：他的电脑是 MacBook Air。 句子（1）避免使用长句。 不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。 123错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。 逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。 （2）尽量使用简单句和并列句，避免使用复合句。 123并列句：他昨天生病了，没有参加会议。复合句：那个昨天生病的人没有参加会议。 （3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。 123错误：请确认没有接通装置的电源。正确：请确认装置的电源已关闭。 （4）避免使用双重否定句。 123错误：没有删除权限的用户，不能删除此文件。正确：用户必须拥有删除权限，才能删除此文件。 写作风格（1）尽量不使用被动语态，改为使用主动语态。 123错误：假如此软件尚未被安装，正确：假如尚未安装这个软件， （2）不使用非正式的语言风格。 123错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！正确：无法参加本次活动，我深感遗憾。 （3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。 123错误：这是唯二的快速启动的方法。正确：这是仅有的两种快速启动的方法。 （4）用对“的”、“地”、“得”。 12345678她露出了开心的笑容。（形容词＋的＋名词）她开心地笑了。（副词＋地＋动词）她笑得很开心。（动词＋得＋副词） （5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。 123错误：从管理系统可以监视中继系统和受其直接控制的分配系统。正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。 （6）名词前不要使用过多的形容词。 123错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。 英文处理（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。 123英文：⋯information stored in random access memory (RAMs)⋯中文：……存储在随机存取存储器（RAM）里的信息…… （2）外文缩写可以使用半角圆点(.)表示缩写。 12U.S.A.Apple, Inc. （3）表示中文时，英文省略号（⋯）应改为中文省略号（……）。 123英文：5 minutes later⋯中文：5 分钟过去了⋯⋯ （4）英文书名或电影名改用中文表达时，双引号应改为书名号。 123英文：He published an article entitled &quot;The Future of the Aviation&quot;.中文：他发表了一篇名为《航空业的未来》的文章。 （5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。 1IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。 （6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。 123“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。“online transaction processing”（在线事务处理）不是专有名词，不应大写。 段落原则 一个段落只能有一个主题，或一个中心句子。 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。 一个段落的长度不能超过七行，最佳段落长度小于等于四行。 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。 段落之间使用一个空行隔开。 段落开头不要留出空白字符。 段落之前不需要缩进。 引用引用第三方内容时，应注明出处。 1One man’s constant is another man’s variable. — Alan Perlis 如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。 1本文转载自 WikiQuote 使用外部图片时，必须在图片下方或文末标明来源。 1本文部分图片来自 Wikipedia 空行 标题和段落之间空1行 段落之间空1行 列表选项之间需要换行 目录选项之间需要换行 代码块之间需要换行 描述文字结尾不需要使用句号 文档标点符号统一使用英文标点符号 冒号之后需要添加空格 区块引用符号后需要添加空格 关键词请使用两个反引号标注 分隔线之间需要有空行 区块引用对内容的引用或注解说明可以使用区块引用 基本格式如下: 描述 1[&gt;][空格][内容] 代码 1&gt; 这是测试区块引用的内容 文档预览效果 这是测试区块引用的内容 允许嵌套使用区块引用 描述 1[&gt;][空格][[&gt;][空格][内容]] 代码 1&gt; &gt; 这是测试区块引用的内容 文档预览效果 这是测试区块引用的内容 数值半角数字数字一律使用半角形式，不得使用全角形式。 123错误： 这件商品的价格是１０００元。正确： 这件商品的价格是 1000 元。 千分号数值为千位以上，应添加千分号（半角逗号）。 1XXX 公司的实收资本为 RMB1,258,000。 对于 4 ～ 6 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于7位及以上的数值，千分号是必须的。 多位小数要从小数点后从左向右添加千分号，比如4.234,345。 货币货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。 12$1,0001,000 美元 数值范围表示数值范围时，用～连接。参见《标点符号》一节的“连接号”部分。 带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。 12345错误：132～234kg正确：132kg～234kg错误：67～89%正确：67%～89% 变化程度的表示法数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。 12345增加到过去的两倍（过去为一，现在为二）增加了两倍（过去为一，现在为三） 数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。 12345降低到百分之八十（定额是一百，现在是八十）降低了百分之八十（原来是一百，现在是二十） 不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。 标点符号原则 中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。 如果整句为英文，则该句使用英文/半角标点。 句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。 句号中文语句中的结尾处应该用全角句号（。）。 句子末尾用括号加注时，句号应在括号之外。 123错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。 逗号逗号，表示句子内部的一般性停顿。 注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。 顿号句子内部的并列词，应该用全角顿号(、) 分隔，而不用逗号，即使并列词是英语也是如此。 123错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 英文句子中，并列词语之间使用半角逗号（,）分隔。 1例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components. 分号分号；表示复句内部并列分句之间的停顿。 引号引用时，应该使用全角双引号（“ ”），注意前后双引号不同。 1例句：许多人都认为客户服务的核心是“友好”和“专业”。 引号里面还要用引号时，外面一层用双引号，里面一层用单引号（‘ ’），注意前后单引号不同。 1例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。” 圆括号补充说明时，使用全角圆括号（），括号前后不加空格。 1例句：请确认所有的连接（电缆和接插件）均安装牢固。 冒号全角冒号（：）常用在需要解释的词语后边，引出解释和说明。 1例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。 表示时间时，应使用半角冒号（:）。 1例句：早上 8:00 省略号省略号……表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用。。。或...等非标准形式。 省略号不应与“等”这个词一起使用。 12345错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……正确：我们为会餐准备了香蕉、苹果、梨等各色水果。 感叹号应该使用平静的语气叙述，尽量避免使用感叹号！。 不得多个感叹号连用，比如！！和!!!。 破折号破折号————一般用于进一步解释。 破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。 123例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。 连接号连接号用于连接两个类似的词。 以下场合应该使用直线连接号（-），占一个半角字符的位置。 两个名词的复合 图表编号 123例句：氧化-还原反应例句：图 1-1 以下场合应该使用波浪连接号（～），占一个全角字符的位置。 数值范围（例如日期、时间或数字） 1例句：2009 年～2011 年 注意，波浪连接号前后两个值都应该加上单位。 波浪连接号也可以用汉字“至”代替。 1例句：周围温度：-20°C 至 -10°C 单词单词和中文之间添加空格 : 介绍 React 和 Vue 的相关文章（注意空格） HTML特殊字符由于Markdown文档默认兼容HTML,所以需要对类似&lt; &amp;等这样的字符进行处理 例如 1「AT&amp;T」 使用&amp;amp;做处理 1「AT&amp;amp;T」 地址链接中处理 例如: 1http://images.google.com/images?num=30&amp;q=larry+bird 处理过后 1http://images.google.com/images?num=30&amp;amp;q=larry+bird 处理&lt;或&lt; 例如: 14&lt;5 处理后 14 &amp;lt; 5 代码缩进代码缩进以2个空格为单位，首行不需要缩进 图片 居中对齐 如果是引用的图片，注明来源 为图片添加注释，例如 （事件触发后，事件处理函数或一些生命周期函数中的 setState 调用会被合并） 目录结构软件手册是一部完整的书，建议采用下面的结构。 简介（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明 快速上手（Getting Started）：[可选] [文件] 如何最快速地使用产品 入门篇（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程 环境准备（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件 安装（Installation）：[可选] [文件] 软件的安装方法 设置（Configuration）：[必备] [文件] 软件的设置 进阶篇（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程 API（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍 FAQ：[可选] [文件] 常见问题解答 附录（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容 Glossary：[可选] [文件] 名词解释 Recipes：[可选] [文件] 最佳实践 Troubleshooting：[可选] [文件] 故障处理 ChangeLog：[可选] [文件] 版本说明 Feedback：[可选] [文件] 反馈方式 下面是两个真实范例，可参考。 Redux 手册 Atom 手册 文件名文档的文件名不得含有空格。 文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。 123错误： 名词解释.md正确： glossary.md 文件名建议只使用小写字母，不使用大写字母。 123错误：TroubleShooting.md正确：troubleshooting.md 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 文件名包含多个单词时，单词之间建议使用半角的连词线（-）分隔。 123不佳：advanced_usage.md正确：advanced-usage.md 分隔线对文档不同内容分区,可以使用分隔线 在一行中可以使用三个星号/减号/下划线来创建一条分隔线,行内不能有其他字符.也可以在星号或是减号中间插入空格,例如 描述 1[分隔线符号] 代码 1234567* * ****- - ---- 文档预览效果 这是测试分隔线 推荐大纲结构了解目标群体，给他们抛出问题，通过逻辑推 演引导他们思考解决方案，推演过程每一步都要基于用户已有的认知,有时候多唠叨几句能够让新手更容易了解你要描述的内容。 1234567891011121314### 前言清楚讲解本篇文章的的核心价值和目的 配以合理的介绍性的文字、图片、代码，甚至是 Demo 对整篇文章的结构大纲有一个概述性的介绍，为后面的核心内容做铺垫和准备### 核心内容(多个)可以讲讲本文所描述的主题相关内容: - 是什么？（What）：这个技术是什么，它的历史介绍等- 为什么？（Why）：为什么我们要使用这个技术，和其他技术之间的比较，延引相关技术内容- 怎样使用? (how): 如何使用这个技术，相关的配置项，使用方式等。- ...### 总结回顾整篇文章，对内容、核心产出、重点做一次总结 援引一些资源、开源库、书籍、文章链接，让读者可以继续学习 给读者以与作者继续保持联系的方法… 总结本文尝试通过规范写作方式，统一大家的文章写作风格，尽量减少低级错误，提高文章质量，希望大家能够遵守我们的写作规范，创造出高质量的文章内容。 参考链接 掘金小册写作参考 中文技术文档的写作规范","categories":[{"name":"常用","slug":"常用","permalink":"https://koala949.github.io/categories/常用/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://koala949.github.io/tags/markdown/"}]},{"title":"es6练习","slug":"Mocha测试","date":"2019-08-27T09:17:57.178Z","updated":"2019-08-27T09:30:22.724Z","comments":true,"path":"2019/08/27/Mocha测试/","link":"","permalink":"https://koala949.github.io/2019/08/27/Mocha测试/","excerpt":"","text":"一、测试框架 Mocha的理解1.安装mocha2.了解测试脚本：12345678describe(&apos;加法函数的测试&apos;, function() &#123; //测试套件函数，表示一组测试（“测试套件名称”，要执行的函数） it(&apos;1 加 1 应该等于 2&apos;, function() &#123; //可以有多个it-测试用例块。（测试用例名称，执行函数） expect(add(1, 1)).to.be.equal(2); //断言 &#125;);&#125;); 二、练习网址点击开始答题推荐练习顺序 Number、Array、Block scope、Destructuring、Object literal、Set、Arrow functions、Rest operator、Spread operator、Default parameters String、Template strings Class、Modules、Object、Iterator、 Promise、Generator Map、Symbol、Unicode、Reflect","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://koala949.github.io/categories/Javascript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://koala949.github.io/tags/es6/"}]},{"title":"js中常用数组和字符串方法","slug":"js-数组字符串方法","date":"2019-08-27T03:15:43.884Z","updated":"2019-08-27T03:32:51.843Z","comments":true,"path":"2019/08/27/js-数组字符串方法/","link":"","permalink":"https://koala949.github.io/2019/08/27/js-数组字符串方法/","excerpt":"","text":"字符串方法首先定义一个字符串： let browserType = &apos;mozilla&apos;; indexOf()找出一个较小的字符串是否存在于一个较大的字符串中 browserType.indexOf(&apos;zilla&apos;);//output:2 browserType.indexOf(&apos;vanilla&apos;);//output:-1 slice()提取字符串中的子字符串，知道开始的位置，以及结束的字符。 browserType.slice(0,3); //output:moz 如果想知道在某个字符之后提取字符串中的所有剩余字符，则不必包含第二个参数，而只需要包含要从中提取的字符位置 字符串中的其余字符。 browserType.slice(2);//output:&apos;zilla&apos; toLowerCase()、toUpperCase()将所有字符分别转换为小写或大写 replace()将字符串中的一个子字符串替换为另一个子字符串,它需要两个参数 - 要被替换下的字符串和要被替换上的字符串。 browserType = browserType.replace(&apos;moz&apos;,&apos;van&apos;);。 数组方法介绍一些相当有用的数组方法，这些方法允许我们将字符串拆分为字符串数组，反之亦然，以及添加或删除元素。 字符串和数组之间的转换 split():作为字符串方法，我们提供一个参数，作为字符串分割的字符，并返回分隔符之间的字串，作为数组中的项。 (1)创建字符串 let myData = &apos;Manchester,London,liverpool,leeds&apos; (2)用逗号分隔： let myArray = myData.split(&apos;,&apos;); console.log(myArray)(3)可以使用join() 方法进行相反的操作 let myNewString = myArray.join(&apos;,&apos;); toString():将数组转换为字符串的另一种方法，可以比join()更简单，因为它不需要一个参数，但更有限制，使用join()可以指定不同的分隔符 let dogNames = [&quot;Rocket&quot;,&quot;Flash&quot;,&quot;Bella&quot;,&quot;Slugger&quot;]; dogNames.toString(); //Rocket,Flash,Bella,Slugger 添加和删除数组项 push()需要添加一个或多个到数组末尾的元素时使用 myArray.push(&apos;Cardiff&apos;); pop()从数组中删除最后一个元素，直接使用 myArray.pop(); unshift()、 shift()从功能上与 push() 和 pop() 完全相同，只是它们分别作用于数组的开始，而不是结尾。 3.练习过的 map()：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。map 不修改调用它的原数组本身。 var new_array = arr.map(function callback(currentValue[ index[, array]]) { }[, thisArg])callback:生成新数组元素的函数，使用三个参数：currentValue:callback 数组中正在处理的当前元素。index可选:callback 数组中正在处理的当前元素的索引。array可选:callback map 方法被调用的数组。thisArg可选:执行 callback 函数时使用的this 值。 every():测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 arr.every(callback[, thisArg]) 例子: function isBigEnough(element, index, array) { return element &gt;= 10; } [12, 5, 8, 130, 44].every(isBigEnough); // false [12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); //箭头函数 false some()测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。 filter()创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) const result = words.filter(word =&gt; word.length &gt; 6);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://koala949.github.io/categories/Javascript/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://koala949.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"https://koala949.github.io/tags/String/"},{"name":"Javascript","slug":"Javascript","permalink":"https://koala949.github.io/tags/Javascript/"}]},{"title":"react学习笔记(一)","slug":"react-基础","date":"2019-08-26T10:10:31.204Z","updated":"2019-08-28T12:32:43.263Z","comments":true,"path":"2019/08/26/react-基础/","link":"","permalink":"https://koala949.github.io/2019/08/26/react-基础/","excerpt":"react学习笔记(一)基础 使用脚手架create-react-app,安装好之后了解结构。yarn.lock 定义了当前使用的确切版本。 还需要用到webpack JSX语法","text":"react学习笔记(一)基础 使用脚手架create-react-app,安装好之后了解结构。yarn.lock 定义了当前使用的确切版本。 还需要用到webpack JSX语法 (1)class写成className，某写属性比如for 要写成 htmlFor.(2)属性值使用表达式，只要用 {} 替换 “”:(3)属性扩散 var props={}; props.foo =x; props.bar =y; var component = &lt;Component {...props}/&gt; props对象的属性会被设置成Component的属性。 组件1.相关基础直观的将一个复杂的页面分割成若干个独立组件，每个组件包含自己的逻辑和样式，既减少逻辑复杂度，又实现代码重用。 两种组件定义方式：(1)函数声明函数参数是属性对象,首字母一定是大写，定义完之后可以像react元素一样使用。组件的渲染过程：封装props对象，调用组件函数得到返回的React元素，ReactDOM把元素转成真实的DOM元素并插入到目标容器。 let Message = (props)=&gt;{ return &lt;h1&gt;{props.msg}&lt;/h1&gt; } 或 let Message = ({msg，id}) =&gt;{ return &lt;h1&gt;{msg}&lt;/h1&gt; } render(&lt;Message msg=&apos;hello&apos; id=&quot;5&quot;/&gt;, document.querySelector(&apos;#root&apos;))函数声明的组件是静态的，否则要手动添加。 setInterval(function(){ render(&lt;Clock/&gt;,...) },1000) (2)类声明通过类声明组件，类需要继承自Component class Clock extends Component{ constructor(){ super();//自定义组件状态对象 //状态可以用来存放组件内部一些变化的值， this.state = {time:new Date().toLocalString()} } //生命周期函数 componentDidMount(){ window.setInterval(()=&gt;{ this.setState({ time:new Date().toLocalString()}) },1000); } } 组件属性(1) 默认属性static defaultProps ={ name:&#39;aaa&#39;}(2) 如果定义组件时希望传入组件的属性有类型和是否必填的限制，则使用ProTypes。组件的属性可以接受任意值，字符串、对象、函数。使用组件的proType属性，验证组件的实例属性是否符合要求。 var MyTitle = React.creatClass({ proTypes:{ title : React.ProTypes.string.isRequired, }, render: function(){ return &lt;h1&gt;{this.props.title}&lt;/h1&gt; } } var data = 123; ReactDom.render(&lt;MyTile title={data}/&gt;,document.body); 验证不通过。(3) React 提供React.Children 来处理this.props.children,可以用React.Children.map来遍历子节点。 (4) Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。 2.组件的生命周期一般一个组件类由extends Component 创建，并且提供render方法以及其他可选的生命周期函数、组件相关的事件或方法来定义。 getInitialState 初始化 this.state 的值，只在组件装载之前调用一次。 如果是使用 ES6 的语法，也可以在构造函数中初始化状态，比如： class Counter extends Component { constructor(props) { super(props); this.state = { count: props.initialCount }; } render() { // ... } } render(必须) react 构建用户界面的库，其元素是JSX元素，其实使用JS来描述页面对象。render的含义就是把一个react元素渲染到dom 容器内部。 reactDoM.render( React.createElement(&apos;div&apos;,null,[React.createElement(&apos;span&apos;,null,[&apos;hello&apos;])]), document.querySelector(&apos;#root&apos;));标签类型，属性对象，子元素。属性名都要写成驼峰写法。 //经过webpack转译后会变成以下形式。 ReactDOM.render(&lt;div&gt; &lt;span&gt;hello&lt; /sapn&gt; &lt;/div&gt;,docoment.querySelector(&apos;#root&apos;)); 小示例：map使用，加key，设置样式和类名 let names = [&apos;一&apos;，&apos;二&apos; ,&apos;三&apos;] ReactDom.render(&lt;div&gt;{ names.map(function (item,index){ return item.length&gt;0?&lt;span style={{backgroundColor:'pink'}} className = &quot;red&quot; key={index}&gt;{item}&lt;/span&gt;:null }) }&lt;/div&gt;,document.querySelector(&apos;#root&apos;)); //有条件的渲染： return item.length&gt;0? 装载组件触发(1)componentWillMount() 只会在装载之前调用一次，在render之前调用，可以在这个方法里面调用 setState 改变状态。(2)componentDidMount() 只会在装载完成之后调用一次，在 render 之后调用，从这里开始可以通过 ReactDOM.findDOMNode(this) 获取到组件的 DOM 节点。 更新组件触发、卸载组件触发。 3.事件处理React 事件的命名采用小驼峰式（camelCase），而不是纯小写。使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。&lt;button onClick={activateLasers}&gt;Activate Lasers&lt;/button&gt; react 不能通过返回false的方式阻止默认行为，必须显示的使用的preventDefault。例如阻止链接默认打开一个新页面。 123456789function ActionLink()&#123; function handleClick(e)&#123; e.preventDefault(); console.log(&apos;the link was clicked&apos;) &#125;&#125;return ( &lt;a href=&quot;#&quot; onclick=&#123;handleClick&#125;&gt;Click me&lt;/a&gt;) 当使用 es6 class 语法定义一个组件时，通常是将事件处理函数声明为class 中的方法： 12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 为了在回调中使用 `this`，这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(state =&gt; (&#123; isToggleOn: !state.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById(&apos;root&apos;)); 要注意的是，class 方法默认不会绑定this.如果没有使用class fields语法，可以在回调中使用箭头函数：&lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;Click me&lt;/button&gt; 4.组合组件使用组件的目的就是通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用，在react组件中要包含其他组件作为子组件，只需要把组件当做一个DOM元素引入。 一个例子：一个显示用户头像的组件 Avatar 包含两个子组件 ProfilePic 显示用户头像和 ProfileLink 显示用户链接： 1234567891011121314151617181920212223import React from &apos;react&apos;import &#123;render&#125; from &apos;react-dom&apos;;const ProfilePic = (props) =&gt;&#123; return(&lt;img src=&#123;&apos;http://graph.facebook.com/&apos; + props.username + &apos;/picture&apos;&#125;&gt;/)&#125;const ProfileLink = (props) =&gt;&#123; return (&lt;a href=&#123;&apos;http://www.facebook.com/&apos;+ props.username&#125;&gt;&#123;props.username&#125;&lt;/a&gt;)&#125;const Avatar = (props)=&gt;&#123; return ( &lt;div&gt; &lt;profilePic username=&#123;props.username&#125;/&gt; &lt;profileLink username=&#123;props.username&#125;/&gt; &lt;/div&gt; )&#125;render( &lt;Avatar username = &apos;xhy&apos;/&gt;, document.getElementById(&apos;example&apos;)) 循环插入子组件如果组件中包含通过循环插入的子组件，为了重新渲染UI的时候能够正确显示这些子元素，每个元素需要通过一个特殊的key属性指定一个唯一值.当元素没有确定 id 的时候，万不得已可以使用元素索引 index 作为 key。key必须在循环中设置。 123456789101112131415161718192021222324function ListItem(props) &#123; // 正确！这里不需要指定 key： return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); this.props.children组件标签里面包含的子元素会通过 props.children传递进来 React.render(&lt;Parent&gt;&lt;Child /&gt;&lt;/Parent&gt;, document.body); React.render(&lt;Parent&gt;&lt;span&gt;hello&lt;/span&gt;{&#39;world&#39;}&lt;/Parent&gt;, document.body); 一般来说，可以直接将这个属性作为父组件的子元素render： const Parent = (props) =&gt; &lt;div&gt;{props.children}&lt;/div&gt; 5.组件间通信 父子组件间的通信很简单，就是通过props属性传递，在父组件给子组件设置 props,然后子组件就可以通过props访问到父组件的数据和方法。 多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const scaleName = &#123; c:&apos;Celsius&apos;, f:&apos;Fahrenheit&apos;&#125;class TemperatureInput extends React.Component&#123; constructor(props)&#123; super(props) this.handleChange = this.handleChange.bind(this) this.state = &#123;temperature: &apos;&apos;&#125; &#125; handleChange(e)&#123; &lt;!-- this.setState(&#123; temperature: e.target.value &#125;); --&gt; this.props.onTemperatureChange(e.target.value); &#125; render()&#123; const temperature = this.props.temperature; const scale = this.props.scale; return( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123; temperature &#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;/fieldset&gt; ) &#125;&#125;//在父组件中： class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: &apos;c&apos;, temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: &apos;f&apos;, temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=&quot;c&quot; temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=&quot;f&quot; temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 无论编辑哪个输入框的内容，Calculator 组件中的 this.state.temperature 和 this.state.scale 均会被更新。其中一个输入框保留用户的输入并取值，另一个输入框始终基于这个值显示转换后的结果。 context在 react 中，数据以自上到下的方向传递，如果一个数据在最顶层，而最底层的组件需要用到这个数据，那么数据需要传递很多层才能到达最底层。这种操作会异常麻烦。顶层父组件中添加 childContextTypes 和 getChildContext, context 就会向下传递。在需要引入的子组件中添加 contextTypes, 即可以 this.context 获取。1234567891011121314151617181920212223242526272829303132//为当前的theme创建一个contextconst ThemeContext = React.createContext(&apos;light&apos;)class App extends React.Component &#123; render()&#123; //使用一个Provider来将当前的theme传递给一下的组件树，无论多深，任何组价都能读取到这个值 //在这个例子中，将dark作为当前值传递下去 return ( &lt;ThemeContext.Provider value=&quot;dark&quot;&gt; &lt;Toolbar/&gt; &lt;/ThemeContext.Provider&gt; ) &#125;&#125;//中间的组件再也不必指明向下传递themefunction Toolbar(props)&#123; return ( &lt;div&gt; &lt;ThemeButton&gt; &lt;/div&gt; )&#125;class ThemeButton extends React.Component &#123; //指定contextType 读取当前的 theme context。 //react 会往上找到最近的theme Provider，然后使用它的值 static contextType = ThemeContext; render()&#123; return &lt;Button theme=&#123;this.context&#125;&gt; &#125;&#125; 虚拟DOM对DOM进行模拟，比较操作前后的数据差异，如果有数据差异，同意操作DOM.(1)受控组件(2)非受控组件","categories":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://koala949.github.io/tags/react/"},{"name":"key","slug":"key","permalink":"https://koala949.github.io/tags/key/"},{"name":"Context","slug":"Context","permalink":"https://koala949.github.io/tags/Context/"}]}]}